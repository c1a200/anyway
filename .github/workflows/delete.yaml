name: Delete
# 定义触发事件，包括定时触发和手动触发，手动触发时只保留最新三条记录，自动执行时保留7天数据
on:
  schedule:
    # 每周日午夜定时触发
    - cron: "0 0 * * SUN"
  workflow_dispatch: # 手动触发

jobs:
  del_runs:
    runs-on: ubuntu-latest
    env:
      # 定义环境变量，分别用于自动和手动触发情况下的保留策略
      RETAIN_DAYS_AUTO: 7
      RETAIN_RUNS_MANUAL: 3
    steps:
      # 设置手动触发时的保留规则
      - name: Set retention strategy for manual trigger
        if: github.event_name == 'workflow_dispatch'
        run: echo "RETAIN_RUNS=${{ env.RETAIN_RUNS_MANUAL }}" >> $GITHUB_ENV

      # 设置定时触发时的保留规则
      - name: Set retention strategy for scheduled trigger
        if: github.event_name == 'schedule'
        run: echo "RETAIN_DAYS=${{ env.RETAIN_DAYS_AUTO }}" >> $GITHUB_ENV

      - name: Debug Info
        run:          echo "Event:${{ github.event_name }}"
          echo "RETAIN_DAYS:${{ env.RETAIN_DAYS }}"
          echo "RETAIN_RUNS:${{ env.RETAIN_RUNS }}"

      - name: Delete old workflow runs
        uses: actions/github-script@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script:            const { Octokit } = require("@octokit/rest");
            const octokit = new Octokit({ auth:process.env.GITHUB_TOKEN });
            const [owner, repoName] = process.env.GITHUB_REPOSITORY.split('/');

            const retainRuns = parseInt(process.env.RETAIN_RUNS, 10) 0;
            const retainDays = parseInt(process.env.RETAIN_DAYS, 10) 0;
            const cutoffDate = retainDays ? new Date(Date.now() - (retainDays * 24 * 60 * 60 * 1000)) :null;

            async function listWorkflowRuns(page = 1, per_page = 100) {
              const result = await octokit.actions.listWorkflowRunsForRepo({
                owner,
                repo:repoName,
                per_page,
                page,
              });
              return result.data.workflow_runs;
            }

            async function deleteWorkflowRun(runId) {
              await octokit.actions.deleteWorkflowRun({
                owner,
                repo:repoName,
                run_id:runId,
              });
              console.log(`Deleted run:${runId}`);
            }

            async function cleanup() {
              let page = 1;
              let runs = [];
              let fetchedRuns = [];
              
              // Fetch all workflow runs
              do {
                fetchedRuns = await listWorkflowRuns(page++);
                runs = runs.concat(fetchedRuns);
              } while (fetchedRuns.length > 0);

              // Sort runs by creation date descending
              runs.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));

              let retainedCount = 0;

              for (const run of runs) {
                if (retainDays && new Date(run.created_at) < cutoffDate && run.status !== "in_progress" && run.status !== "queued") {
                  await deleteWorkflowRun(run.id);
                } else if (retainRuns && retainedCount >= retainRuns) {
                  if (run.status !== "in_progress" && run.status !== "queued") {
                    await deleteWorkflowRun(run.id);
                  }
                } else {
                  retainedCount += 1;
                }
              }
            }

            cleanup().catch(err => {
              console.error(`Error during cleanup: ${err}`);
              process.exit(1);
            });
